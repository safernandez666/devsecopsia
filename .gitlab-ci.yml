stages:
  - build
  - security
  - report

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""

build:
  stage: build
  image: docker:latest
  tags:
    - docker
  services:
    - docker:dind
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
  script:
    - docker build -t "$CI_REGISTRY_IMAGE:${CI_COMMIT_SHA:0:8}" -t "$CI_REGISTRY_IMAGE:latest" .
    - docker push "$CI_REGISTRY_IMAGE:${CI_COMMIT_SHA:0:8}"
    - docker push "$CI_REGISTRY_IMAGE:latest"

bandit-scan:
  stage: security
  image: python:3.9-slim
  tags:
    - docker
  before_script:
    - pip install bandit
  script:
    - echo "Ejecutando análisis de seguridad con Bandit..."
    - bandit -r . -f txt || true
    - bandit -r . -f json -o bandit-report.json || true
  artifacts:
    paths:
      - bandit-report.json
    expire_in: 1 week
  allow_failure: true

safety-scan:
  stage: security
  image: python:3.9-slim
  tags:
    - docker
  before_script:
    - pip install safety
  script:
    - echo "Analizando dependencias vulnerables..."
    - safety check --file requirements.txt --output text || true
    - safety check --file requirements.txt --output json > safety-report.json || true
  artifacts:
    paths:
      - safety-report.json
    expire_in: 1 week
  allow_failure: true

gitleaks-scan:
  stage: security
  image: alpine:latest
  tags:
    - docker
  before_script:
    - apk add --no-cache git
    - wget -O gitleaks.tar.gz https://github.com/gitleaks/gitleaks/releases/download/v8.18.4/gitleaks_8.18.4_linux_arm64.tar.gz
    - tar -xzf gitleaks.tar.gz
    - chmod +x gitleaks
    - mv gitleaks /usr/local/bin/
  script:
    - echo "Preparando escaneo..."
    - rm -f ./*.md README.md CHANGELOG.md 2>/dev/null || true
    - echo "Escaneando secretos en código fuente..."
    - gitleaks detect --source . --no-git --report-format json --report-path /tmp/gitleaks-report.json --verbose --exit-code 0
    - gitleaks detect --source . --no-git --report-format sarif --report-path /tmp/gitleaks-report.sarif --verbose --exit-code 0
    - mv /tmp/gitleaks-report.json ./gitleaks-report.json
    - mv /tmp/gitleaks-report.sarif ./gitleaks-report.sarif
    - echo "Verificando si hay leaks en código fuente..."
    - gitleaks detect --source . --no-git --verbose
  artifacts:
    paths:
      - gitleaks-report.json
      - gitleaks-report.sarif
    expire_in: 1 week
    when: always
  allow_failure: false

trivy-scan:
  stage: security
  image: docker:latest
  tags:
    - docker
  variables:
    DOCKER_HOST: unix:///var/run/docker.sock
  before_script:
    - apk add --no-cache curl
    - curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
  script:
    - echo "Pulling image from registry..."
    - docker pull localhost:5001/root/python-application:latest
    - echo "Escaneando imagen Docker con Trivy..."
    - trivy image --format table localhost:5001/root/python-application:latest
    - echo "Generando reporte JSON..."
    - trivy image --format json --output trivy-report.json localhost:5001/root/python-application:latest
  artifacts:
    paths:
      - trivy-report.json
    expire_in: 1 week
  allow_failure: true
  dependencies:
    - build

upload-defectdojo:
  stage: report
  image: python:3.9-slim
  tags:
    - docker
  needs:
    - job: bandit-scan
      artifacts: true
    - job: trivy-scan
      artifacts: true
    - job: gitleaks-scan
      artifacts: true
  before_script:
    - pip install requests
  script:
    - ls -la
    - |
      python3 << 'EOF'
      import requests
      import os
      
      # Usar localhost porque el runner está en network_mode: host
      DEFECTDOJO_URL = "http://localhost:8080"
      API_KEY = os.getenv('DEFECTDOJO_API_KEY')
      
      headers = {'Authorization': f'Token {API_KEY}'}
      
      try:
          product_types = requests.get(f'{DEFECTDOJO_URL}/api/v2/product_types/', headers=headers).json()
          
          product_type_id = None
          for pt in product_types.get('results', []):
              if pt['name'] == 'Web Application':
                  product_type_id = pt['id']
                  break
          
          if not product_type_id:
              pt_response = requests.post(
                  f'{DEFECTDOJO_URL}/api/v2/product_types/',
                  headers=headers,
                  json={'name': 'Web Application', 'description': 'Web applications'}
              )
              if pt_response.status_code == 201:
                  product_type_id = pt_response.json()['id']
          
          print(f"Product Type ID: {product_type_id}")
          
          product_name = "Python Application"
          products = requests.get(f'{DEFECTDOJO_URL}/api/v2/products/', headers=headers).json()
          
          product_id = None
          for p in products.get('results', []):
              if p['name'] == product_name:
                  product_id = p['id']
                  break
          
          if not product_id:
              product_response = requests.post(
                  f'{DEFECTDOJO_URL}/api/v2/products/',
                  headers=headers,
                  json={
                      'name': product_name,
                      'description': 'Python Flask Application',
                      'prod_type': product_type_id
                  }
              )
              
              if product_response.status_code == 201:
                  product_id = product_response.json()['id']
          
          print(f"Product ID: {product_id}")
          
          engagement_name = f"Pipeline {os.getenv('CI_PIPELINE_ID')}"
          engagement_response = requests.post(
              f'{DEFECTDOJO_URL}/api/v2/engagements/',
              headers=headers,
              json={
                  'name': engagement_name,
                  'product': product_id,
                  'target_start': '2025-01-01',
                  'target_end': '2025-12-31',
                  'engagement_type': 'CI/CD'
              }
          )
          
          if engagement_response.status_code != 201:
              print(f"Failed to create engagement: {engagement_response.text}")
              exit(1)
              
          engagement_id = engagement_response.json()['id']
          print(f"Engagement ID: {engagement_id}")
          
          if os.path.exists('bandit-report.json'):
              with open('bandit-report.json', 'rb') as f:
                  response = requests.post(
                      f'{DEFECTDOJO_URL}/api/v2/import-scan/',
                      headers={'Authorization': f'Token {API_KEY}'},
                      files={'file': f},
                      data={
                          'engagement': engagement_id,
                          'scan_type': 'Bandit Scan',
                          'environment': 'Development',
                          'verified': 'true'
                      }
                  )
                  print(f"Bandit uploaded: {response.status_code}")
          
          if os.path.exists('trivy-report.json'):
              with open('trivy-report.json', 'rb') as f:
                  response = requests.post(
                      f'{DEFECTDOJO_URL}/api/v2/import-scan/',
                      headers={'Authorization': f'Token {API_KEY}'},
                      files={'file': f},
                      data={
                          'engagement': engagement_id,
                          'scan_type': 'Trivy Scan',
                          'environment': 'Development',
                          'verified': 'true'
                      }
                  )
                  print(f"Trivy uploaded: {response.status_code}")
          
          if os.path.exists('gitleaks-report.sarif'):
              with open('gitleaks-report.sarif', 'rb') as f:
                  response = requests.post(
                      f'{DEFECTDOJO_URL}/api/v2/import-scan/',
                      headers={'Authorization': f'Token {API_KEY}'},
                      files={'file': f},
                      data={
                          'engagement': engagement_id,
                          'scan_type': 'Gitleaks Scan',
                          'environment': 'Development',
                          'verified': 'true'
                      }
                  )
                  print(f"GitLeaks uploaded: {response.status_code}")
          
          print(f"\n✓ DefectDojo: http://localhost:8080/engagement/{engagement_id}")
          
      except Exception as e:
          print(f"Error: {e}")
          exit(1)
      EOF
  allow_failure: true

